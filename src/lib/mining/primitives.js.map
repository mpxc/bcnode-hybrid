{"version":3,"sources":["../../src/mining/primitives.es6"],"names":["getExpFactorDiff","getDiff","createMerkleRoot","split","dist","distance","distanceFromCache","mine","getParentShareDiff","getMinimumDifficulty","getNewPreExpDifficulty","prepareWork","getNewBlockCount","getChildBlockDiff","getUniqueHashes","getUniqueBlocks","prepareNewBlock","inspect","require","similarity","BN","Random","call","compose","difference","flip","groupBy","invoker","join","last","map","partialRight","reduce","repeat","reverse","splitEvery","toPairs","zip","zipWith","blake2bl","concatAll","Block","BcBlock","BcTransaction","BlockchainHeader","BlockchainHeaders","ts","default","GENESIS_DATA","MINIMUM_DIFFICULTY","MAX_TIMEOUT_SECONDS","logging","logger","getLogger","__filename","calculatedDifficulty","parentBlockHeight","big1","big2","expDiffPeriod","periodCount","add","div","gt","y","sub","pow","currentBlockTime","previousBlockTime","previousDifficulty","minimalDifficulty","newBlockCount","bigMinimalDifficulty","debug","bigPreviousBlockTime","bigPreviousDifficulty","bigCurentBlockTime","bigMinus99","big0","bigTargetTimeWindow","elapsedTime","elapsedTimeBonus","mul","x","lt","list","prev","length","undefined","shift","t","an","charCodeAt","clbk","s","arguments","a","b","aChunks","bChunks","chunks","value","all","Math","floor","bchunkslength","ceil","len","min","i","theend","slice","currentTimestamp","work","miner","merkleRoot","threshold","difficultyCalculator","difficulty","difficultyBN","result","tsStart","now","maxCalculationEnd","currentLoopTimestamp","workChunks","iterations","res","nowms","nonce","String","abs","engines","nativeMath","toString","timestamp","timeDiff","nonceHash","info","toHexBuffer","Buffer","hash","blockHash","getChildrenBlocksHashes","blockchainMapToList","headersMap","Object","keys","toObject","listName","getMethodName","toUpperCase","acc","curr","concat","getChildrenRootHash","xor","parentDifficulty","childChainCount","lastPreviousBlock","preExpDiff","getTimestamp","getDifficulty","previousBlockHash","childrenCurrentBlocks","newChainRoot","copyHeader","block","confirmations","header","setBlockchain","getBlockchain","setHash","getHash","setPreviousHash","getPreviousHash","setTimestamp","setHeight","getHeight","setMerkleRoot","getMerkleRoot","setBlockchainConfirmationsInParentCount","prepareChildBlockHeadersMapForGenesis","currentBlockchainHeaders","newMap","forEach","blockchainHeader","methodNameSet","prepareChildBlockHeadersMap","previousBlock","newChildBlock","newChildHeaders","newChildHeadersMap","keyOrMethodToChain","keyOrMethod","replace","toLowerCase","chainToSet","chain","chainToGet","blocks","depth","newBlockchainHeaders","listKey","newlyAssignedBlocks","lastHeaderFromPreviousBlock","getBlockchainHeaders","Error","headerFromPreviousBlock","getBlockchainConfirmationsInParentCount","values","previousBlockHeaders","currentBlockHeaders","total","key","sa","sb","headersToHashes","headers","headerObj","previousHashes","currentHashes","diff","filterToDiff","filter","indexOf","blockWhichTriggeredMining","newTransactions","minerAddress","unfinishedBlock","childBlockHeaders","height","blockHashes","finalDifficulty","newHeight","newMerkleRoot","version","schemaVersion","nrgGrant","blockchainFingerprintsRoot","chainWeight","getDistance","divRound","newBlock","setVersion","setSchemaVersion","setMiner","setDifficulty","setChainRoot","setDistance","setTotalDistance","getTotalDistance","setNrgGrant","setTargetHash","targetHash","setTargetHeight","targetHeight","setTargetMiner","targetMiner","setTargetSignature","targetSignature","setTwn","twn","setTwsList","twsList","setEmblemWeight","emblemWeight","setEmblemChainBlockHash","emblemChainBlockHash","setEmblemChainFingerprintRoot","emblemChainFingerprintRoot","setEmblemChainAddress","emblemChainAddress","setTxCount","setTxsList","setBlockchainHeadersCount","setBlockchainFingerprintsRoot","setTxFeeBase","txFeeBase","setTxDistanceSumLimit","txDistanceSumLimit","setBlockchainHeaders"],"mappings":"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","file":"primitives.js","sourcesContent":["/**\n * Copyright (c) 2017-present, blockcollider.org developers, All rights reserved.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * TODO: Fix flow issues\n * @flow\n */\n\n/**\n *    DOCUMENT IN FOUR PARTS\n *\n *      PART 1: Difficulty of the next block [COMPLETE]\n *\n *      PART 2: Mining a block hash [COMPLETE]\n *\n *      PART 3: Blockchain header proofs [IN PROGRESS]\n *\n *      PART 4: Create Block Collider Block Hash  [COMPLETE]\n *\n */\n\nimport type { Logger } from 'winston'\n\nconst { inspect } = require('util')\n\nconst similarity = require('compute-cosine-similarity')\nconst BN = require('bn.js')\nconst Random = require('random-js')\nconst {\n  call,\n  compose,\n  difference,\n  flip,\n  groupBy,\n  invoker,\n  join,\n  last,\n  map,\n  // $FlowFixMe - missing in ramda flow-typed annotation\n  partialRight,\n  reduce,\n  repeat,\n  reverse,\n  splitEvery,\n  toPairs,\n  zip,\n  zipWith\n} = require('ramda')\n\nconst { blake2bl } = require('../utils/crypto')\nconst { concatAll } = require('../utils/ramda')\nconst { Block, BcBlock, BcTransaction, BlockchainHeader, BlockchainHeaders } = require('../protos/core_pb')\nconst ts = require('../utils/time').default // ES6 default export\nconst GENESIS_DATA = require('../bc/genesis.raw')\n\nconst MINIMUM_DIFFICULTY = new BN(290112262029012, 16)\n// testnet: 11801972029393\nconst MAX_TIMEOUT_SECONDS = 300\n\nconst logging = require('../logger')\nconst logger: Logger = logging.getLogger(__filename)\n\n/// /////////////////////////////////////////////////////////////////////\n/// ////////////////////////\n/// ////////////////////////  PART 1  - Dificulty of the next block\n/// ////////////////////////\n/// /////////////////////////////////////////////////////////////////////\n\n/**\n * Determines the singularity height and difficulty\n *\n * @param calculatedDifficulty\n * @param parentBlockHeight\n * @returns a\n */\nexport function getExpFactorDiff (calculatedDifficulty: BN, parentBlockHeight: number): BN {\n  const big1 = new BN(1, 16)\n  const big2 = new BN(2, 16)\n  const expDiffPeriod = new BN(66000000, 16)\n\n  // periodCount = (parentBlockHeight + 1) / 66000000\n  let periodCount = new BN(parentBlockHeight).add(big1)\n  periodCount = periodCount.div(expDiffPeriod)\n\n  // if (periodCount > 2)\n  if (periodCount.gt(big2) === true) {\n    // return calculatedDifficulty + (2 ^ (periodCount - 2))\n    let y = periodCount.sub(big2)\n    y = big2.pow(y)\n    calculatedDifficulty = calculatedDifficulty.add(y)\n    return calculatedDifficulty\n  }\n  return calculatedDifficulty\n}\n\n/**\n * FUNCTION: getDiff(t)\n *   Gets the difficulty of a given blockchain without singularity calculation\n *\n * @param currentBlockTime\n * @param previousBlockTime\n * @param previousDifficulty\n * @param minimalDifficulty\n * @param newBlockCount\n * @returns\n */\nexport function getDiff (currentBlockTime: number, previousBlockTime: number, previousDifficulty: string, minimalDifficulty: number, newBlockCount: number): BN {\n  // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.md\n\n  let bigMinimalDifficulty = new BN(minimalDifficulty, 16)\n\n  logger.debug('number of new blocks: ' + newBlockCount)\n\n  const bigPreviousBlockTime = new BN(previousBlockTime)\n  const bigPreviousDifficulty = new BN(previousDifficulty)\n  const bigCurentBlockTime = new BN(currentBlockTime)\n  const bigMinus99 = new BN(-99)\n  const big1 = new BN(1)\n  const big0 = new BN(0)\n  const bigTargetTimeWindow = new BN(8)\n  let elapsedTime = bigCurentBlockTime.sub(bigPreviousBlockTime)\n\n  // elapsedTime + ((elapsedTime - 4) * newBlocks)\n  const elapsedTimeBonus = elapsedTime.add(elapsedTime.sub(new BN(5)).mul(new BN(newBlockCount)))\n\n  if (elapsedTimeBonus.gt(big0)) {\n    elapsedTime = elapsedTimeBonus\n  }\n\n  // x = 1 - floor(x / handicap)\n  let x = big1.sub(elapsedTime.div(bigTargetTimeWindow)) // div floors by default\n  let y\n\n  // x < -99 ? -99 : x\n  if (x.lt(bigMinus99)) {\n    x = bigMinus99\n  }\n\n  // y = bigPreviousDifficulty -> SPECTRUM: 10062600 // AT: 1615520 // BT: (32 * 16) + 20 = 532\n  y = bigPreviousDifficulty.div(new BN(532))\n  // x = x * y\n  x = x.mul(y)\n  // x = x + previousDifficulty\n  x = x.add(bigPreviousDifficulty)\n\n  // x < minimalDifficulty\n  if (x.lt(bigMinimalDifficulty)) {\n    return bigMinimalDifficulty\n  }\n\n  return x\n}\n\nexport function createMerkleRoot (list: string[], prev: ?string): string {\n  if (list.length > 0) {\n    if (prev !== undefined) {\n      // $FlowFixMe\n      prev = blake2bl(prev + list.shift())\n    } else {\n      prev = blake2bl(list.shift())\n    }\n    return createMerkleRoot(list, prev)\n  }\n  // $FlowFixMe\n  return prev\n}\n\n/// /////////////////////////////////////////////////////////////////////\n/// ////////////////////////\n/// ////////////////////////  PART 2 - Mining a Block\n/// ////////////////////////\n/// /////////////////////////////////////////////////////////////////////\n\n/**\n * The Blake2BL hash of the proof of a block\n */\n// const blockProofs = [\n//   '9b80fc5cba6238801d745ca139ec639924d27ed004c22609d6d9409f1221b8ce', // BTC\n//   '781ff33f4d7d36b3f599d8125fd74ed37e2a1564ddc3f06fb22e1b0bf668a4f7', // ETH\n//   'e0f0d5bc8d1fd6d98fc6d1487a2d59b5ed406940cbd33f2f5f065a2594ff4c48', // LSK\n//   'ef631e3582896d9eb9c9477fb09bf8d189afd9bae8f5a577c2107fd0760b022e', // WAV\n//   'e2d5d4f3536cdfa49953fb4a96aa3b4a64fd40c157f1b3c69fb84b3e1693feb0', // NEO\n//   '1f591769bc88e2307d207fc4ee5d519cd3c03e365fa16bf5f63f449b46d6cdef' // EMB (Block Collider)\n// ]\n\n/**\n *  Converts characters of string into ASCII codes\n *\n * @returns {Number|Array}\n */\nexport function split (t: string): number[] {\n  return t.split('').map(function (an) {\n    return an.charCodeAt(0)\n  })\n}\n\n/**\n * Converts cosine similary to cos distance\n */\nexport function dist (x: number[], y: number[], clbk: ?Function): number {\n  let s\n  if (arguments.length > 2) {\n    s = similarity(x, y, clbk)\n  } else {\n    s = similarity(x, y)\n  }\n  return s !== null ? 1 - s : s\n}\n\n/**\n * Returns summed distances between two strings broken into of 8 bits\n *\n * @param {string} a\n * @param {string} b\n * @returns {number} cosine distance between two strings\n */\nexport function distance (a: string, b: string): number {\n  const aChunks = reverse(splitEvery(32, split(a)))\n  const bChunks = splitEvery(32, split(b))\n  const chunks = zip(aChunks, bChunks)\n\n  const value = chunks.reduce(function (all, [a, b]) {\n    return all + dist(b, a)\n  }, 0)\n\n  // TODO this is the previous implementation - because of\n  // ac.pop() we need to reverse(aChunks) to produce same number\n  // is that correct or just side-effect?\n  // const value = bc.reduce(function (all, bd, i) {\n  //   return all + dist(bd, ac.pop())\n  // }, 0)\n  return Math.floor(value * 1000000000000000) // TODO: Move to safe MATH\n}\n\n// this is an implementation of distance that\n// allows us to not recalculate the split() and reverse()\n// of a every time, since it's constant\nexport function distanceFromCache (aChunks: string[], b: string): number {\n  // const aChunks = reverse(splitEvery(32, split(a)))\n  const bChunks = split(b)\n\n  const bchunkslength = Math.ceil(bChunks.length / 32)\n  let value = 0\n  const len = Math.min(aChunks.length, bchunkslength)\n  for (var i = 0; i < len; i++) {\n    const theend = Math.min(32 * (i + 1), bChunks.length)\n    // logger.info('aChunks: '+aChunks[i]+' '+aChunks[i].length)\n    value += dist(bChunks.slice(32 * i, theend), aChunks[i])\n  }\n\n  // const chunks = zip(aChunks, bChunks)\n  // const value = chunks.reduce(function (all, [a, b]) {\n  //  return all + dist(b, a)\n  // }, 0)\n\n  // TODO this is the previous implementation - because of\n  // ac.pop() we need to reverse(aChunks) to produce same number\n  // is that correct or just side-effect?\n  // const value = bc.reduce(function (all, bd, i) {\n  //   return all + dist(bd, ac.pop())\n  // }, 0)\n  return Math.floor(value * 1000000000000000) // TODO: Move to safe MATH\n}\n\n/**\n * Finds the mean of the distances from a provided set of hashed header proofs\n *\n * @param {number} currentTimestamp current time reference\n * @param {string} work reference to find distance > `threshold`\n * @param {string} miner Public address to which NRG award for mining the block and transactions will be credited to\n * @param {string} merkleRoot Mekle root of the BC block being mined\n * @param {number} threshold threshold for the result to be valid\n * @param {function} difficultyCalculator function for recalculating difficulty at given timestamp\n * @returns {Object} result containing found `nonce` and `distance` where distance is > `threshold` provided as parameter\n */\n// $FlowFixMe will never return anything else then a mining result\nexport function mine (currentTimestamp: number, work: string, miner: string, merkleRoot: string, threshold: number, difficultyCalculator: ?Function): { distance: string, nonce: string, timestamp: number, difficulty: string } {\n  let difficulty = threshold\n  let difficultyBN = new BN(difficulty)\n  let result\n  const tsStart = ts.now()\n  const maxCalculationEnd = tsStart + (MAX_TIMEOUT_SECONDS * 1000)\n  let currentLoopTimestamp = currentTimestamp\n\n  const workChunks = reverse(splitEvery(32, split(work)))\n\n  let iterations = 0\n  let res = null\n  let nowms = 0\n  let now = 0\n  let nonce = String(Math.abs(Random.engines.nativeMath())) // random string\n  while (true) {\n    iterations += 1\n\n    // TODO optimize not to count each single loop\n    nowms = ts.now()\n    now = (nowms / 1000) << 0\n    if (maxCalculationEnd < nowms) {\n      break\n    }\n\n    if (new BN(result).gt(difficultyBN) === true) {\n      res = {\n        distance: (result).toString(),\n        nonce,\n        timestamp: currentLoopTimestamp,\n        difficulty,\n        // NOTE: Following fields are for debug purposes only\n        iterations,\n        timeDiff: nowms - tsStart\n      }\n      break\n    }\n\n    // recalculate difficulty each second\n    if (difficultyCalculator && currentLoopTimestamp < now) {\n      currentLoopTimestamp = now\n      difficulty = difficultyCalculator(now)\n      difficultyBN = new BN(difficulty)\n      // logger.info(`In timestamp: ${currentLoopTimestamp} recalculated difficulty is: ${difficulty}`)\n    }\n\n    nonce = String(Math.abs(Random.engines.nativeMath())) // random string\n    const nonceHash = blake2bl(nonce)\n    result = distanceFromCache(workChunks, blake2bl(miner + merkleRoot + nonceHash + currentLoopTimestamp))\n  }\n\n  logger.info('mining took ' + iterations + ' iterations in ' + res.timeDiff + ' ms!')\n\n  return res\n}\n\n/// /////////////////////////////////////////////////////////////////////\n/// ////////////////////////\n/// ////////////////////////  PART 3 - Blockchain Header Proofs\n/// ////////////////////////\n/// /////////////////////////////////////////////////////////////////////\n\n/*\n * It will look like this:\n *\n *      function createBlockProof(blockchainFingerprint, rawBlock, callback)\n *\n * Where the fingerprint for Ethereum is \"bbe5c469c469cec1f8c0b01de640df724f3d9053c23b19c6ed1bc6ee0faf5160\"\n * as seen in bcnode/src/utils/templates/blockchain_fingerprints.json\n *\n */\nconst toHexBuffer: ((string) => Buffer) = partialRight(invoker(2, 'from'), ['hex', Buffer])\nconst hash: ((BlockchainHeader|Block) => string) = invoker(0, 'getHash')\nconst merkleRoot: ((BlockchainHeader|Block) => string) = invoker(0, 'getMerkleRoot')\n\n/**\n * Computes hash form a rovered block header as blake2bl(hash + mekleRoot)\n * @param {BlockchainHeader|Block} block to hash\n * @return {string} hash of the block\n */\nconst blockHash: (BlockchainHeader|Block => string) = compose(\n  blake2bl,\n  join(''),\n  zipWith(call, [hash, merkleRoot]),\n  flip(repeat)(2)\n)\n\nexport const getChildrenBlocksHashes: ((BlockchainHeader[]|Block[]) => string[]) = map(blockHash)\n\n// TODO should maintain sort (btc -> eth -> lsk -> neo -> wav)\nexport const blockchainMapToList = (headersMap: BlockchainHeaders): BlockchainHeader[] => {\n  return Object.keys(headersMap.toObject()).map(listName => {\n    const getMethodName = `get${listName[0].toUpperCase()}${listName.slice(1)}`\n    return headersMap[getMethodName]()\n  }).reduce((acc, curr) => {\n    return acc.concat(curr)\n  }, [])\n}\n\nexport const getChildrenRootHash = reduce((all: BN, blockHash: string) => {\n  return all.xor(new BN(toHexBuffer(blockHash)))\n}, new BN(0))\n\nexport function getParentShareDiff (parentDifficulty: number, childChainCount: number): BN {\n  return (new BN(parentDifficulty)).div(new BN(childChainCount))\n}\n\nexport function getMinimumDifficulty (childChainCount: number): BN {\n  // Standard deviation 100M cycles divided by the number of chains\n  return MINIMUM_DIFFICULTY.div(new BN(childChainCount))\n}\n\n// TODO rename arguments to better describe data\nexport function getNewPreExpDifficulty (\n  currentTimestamp: number,\n  lastPreviousBlock: BcBlock,\n  newBlockCount: number\n) {\n  const preExpDiff = getDiff(\n    currentTimestamp,\n    lastPreviousBlock.getTimestamp(),\n    lastPreviousBlock.getDifficulty(),\n    MINIMUM_DIFFICULTY,\n    newBlockCount\n  ) // Calculate the final pre-singularity difficulty adjustment\n\n  return preExpDiff\n}\n\n/**\n * Return the `work` - string to which the distance is being guessed while mining\n *\n * @param {string} previousBlockHash Hash of last known previously mined BC block\n * @param {BlockchainHeaders} childrenCurrentBlocks Last know rovered blocks from each chain (one of them is the one which triggered mining)\n * @return {string} a hash representing the work\n */\nexport function prepareWork (previousBlockHash: string, childrenCurrentBlocks: BlockchainHeaders): string {\n  const newChainRoot = getChildrenRootHash(getChildrenBlocksHashes(blockchainMapToList(childrenCurrentBlocks)))\n  const work = blake2bl(\n    newChainRoot.xor(\n      new BN(\n        toHexBuffer(previousBlockHash)\n      )\n    ).toString()\n  )\n\n  return work\n}\n\nconst copyHeader = (block: BlockchainHeader|Block, confirmations: number): BlockchainHeader => {\n  const header = new BlockchainHeader()\n  header.setBlockchain(block.getBlockchain())\n  header.setHash(block.getHash())\n  header.setPreviousHash(block.getPreviousHash())\n  header.setTimestamp(block.getTimestamp())\n  header.setHeight(block.getHeight())\n  header.setMerkleRoot(block.getMerkleRoot())\n  header.setBlockchainConfirmationsInParentCount(confirmations)\n  return header\n}\n\nfunction prepareChildBlockHeadersMapForGenesis (currentBlockchainHeaders: Block[]): BlockchainHeaders {\n  const newMap = new BlockchainHeaders()\n  currentBlockchainHeaders.forEach(header => {\n    const blockchainHeader = copyHeader(header, 1)\n    const methodNameSet = `set${header.getBlockchain()[0].toUpperCase() + header.getBlockchain().slice(1)}List` // e.g. setBtcList\n    newMap[methodNameSet]([blockchainHeader])\n  })\n  return newMap\n}\n\n/**\n * Create a BlockchainHeader{} for new BcBlock, before count new confirmation count for each child block.\n *\n * Assumption here is that confirmation count of all headers from previous block is taken and incrementend by one\n * except for the one which caused the new block being mine - for that case is is reset to 1\n *\n * We're starting from 1 here because it is used for dividing\n *\n * @param {BcBlock} previousBlock Last known previously mined BC block\n * @param {Block} newChildBlock The last rovereed block - this one triggered the mining\n * @param {Block[]} newChildHeaders child headers which were rovered since the previousBlock\n * @return {BlockchainHeader[]} Headers of rovered chains with confirmations count calculated\n */\nfunction prepareChildBlockHeadersMap (previousBlock: BcBlock, newChildBlock: Block, newChildHeaders: Block[]): BlockchainHeaders {\n  const newChildHeadersMap = groupBy(block => block.getBlockchain(), newChildHeaders)\n\n  const keyOrMethodToChain = (keyOrMethod: string) => keyOrMethod.replace(/^get|set/, '').replace(/List$/, '').toLowerCase()\n  const chainToSet = (chain: string) => `set${chain[0].toUpperCase() + chain.slice(1)}List`\n  const chainToGet = (chain: string) => `get${chain[0].toUpperCase() + chain.slice(1)}List`\n\n  logger.debug(`newChildHeadersMap: ${inspect(toPairs(newChildHeadersMap).map(([chain, blocks]) => {\n    return 'chain: ' + chain + ' headers ' + inspect(blocks.map(block => copyHeader(block, 1).toObject()))\n  }), {depth: 3})}`)\n\n  const newBlockchainHeaders = new BlockchainHeaders()\n  // construct new BlockchainHeaders from newChildHeaders\n  toPairs(newChildHeadersMap).forEach(([chain, blocks]) => {\n    newBlockchainHeaders[chainToSet(chain)](blocks.map(block => copyHeader(block, 1)))\n  })\n\n  // if any list in header is empty take last header from previous block and raise confirmations by 1\n  Object.keys(newBlockchainHeaders.toObject()).forEach(listKey => {\n    const chain = keyOrMethodToChain(listKey)\n    const newlyAssignedBlocks = newBlockchainHeaders[chainToGet(chain)]()\n    logger.debug(`headers empty check, with method ${chainToGet(chain)}: ${newlyAssignedBlocks.map(b => b.toObject())}`)\n    if (newlyAssignedBlocks.length === 0) {\n      const lastHeaderFromPreviousBlock = last(previousBlock.getBlockchainHeaders()[chainToGet(chain)]())\n      if (!lastHeaderFromPreviousBlock) {\n        throw new Error(`Previous BC block ${previousBlock.getHeight()} does not have any \"${chain}\" headers`)\n      }\n      const headerFromPreviousBlock = copyHeader(lastHeaderFromPreviousBlock, lastHeaderFromPreviousBlock.getBlockchainConfirmationsInParentCount() + 1)\n      newBlockchainHeaders[chainToSet(chain)]([headerFromPreviousBlock])\n    }\n  })\n\n  logger.debug(`prepareChildBlockHeadersMap: previous BC block: ${previousBlock.getHeight()} final headers: ${inspect(Object.values(newBlockchainHeaders.toObject()), {depth: 3})}`)\n\n  return newBlockchainHeaders\n}\n\n/**\n * How many new child blocks are between previousBlockHeaders and currentBlockHeaders\n */\nexport function getNewBlockCount (previousBlockHeaders: BlockchainHeaders, currentBlockHeaders: BlockchainHeaders) {\n  // $FlowFixMe - protbuf toObject is not typed\n  return getChildBlockDiff(previousBlockHeaders, currentBlockHeaders)\n  // const headersToHashes = (headers: BlockchainHeaders) => Object.values(currentBlockHeaders.toObject()).reduce((acc, curr) => acc.concat(curr), []).map(headerObj => headerObj.hash)\n  // const previousHashes = headersToHashes(previousBlockHeaders)\n  // const currentHashes = headersToHashes(currentBlockHeaders)\n\n  // return difference(currentHashes, previousHashes).length\n}\n\n/**\n * How many new child blocks are between previousBlockHeaders and currentBlockHeaders\n */\nexport function getChildBlockDiff (previousBlockHeaders: BlockchainHeaders, currentBlockHeaders: BlockchainHeaders) {\n  // $FlowFixMe - protbuf toObject is not typed\n  const a = previousBlockHeaders.toObject()\n  const b = currentBlockHeaders.toObject()\n\n  return Object.keys(b).reduce((total, key) => {\n    const sa = a[key].map((header) => { return header.hash })\n    const sb = b[key].map((header) => { return header.hash })\n    total = total + difference(sa, sb).length\n    return total\n  }, 0)\n}\n\n/**\n * How many new child HASHES are between previousBlockHeaders and currentBlockHeaders\n */\nexport function getUniqueHashes (previousBlockHeaders: BlockchainHeaders, currentBlockHeaders: BlockchainHeaders) {\n  // $FlowFixMe - protbuf toObject is not typed\n  const headersToHashes = (headers: BlockchainHeaders) => Object.values(previousBlockHeaders.toObject()).reduce((acc, curr) => acc.concat(curr), []).map(headerObj => headerObj.hash)\n  const previousHashes = headersToHashes(previousBlockHeaders)\n  logger.info('previousHashes: ' + previousHashes)\n  const currentHashes = headersToHashes(currentBlockHeaders)\n  logger.info('currentHashes: ' + currentHashes)\n\n  return difference(currentHashes, previousHashes)\n  // return currentBlockHeaders.filter((b) => {\n  //  if (diff.indexOf(b.getHash()) > -1) {\n  //    return b\n  //  }\n  // })\n}\n\n/**\n * How many new child blocks are between previousBlockHeaders and currentBlockHeaders\n */\nexport function getUniqueBlocks (previousBlockHeaders: BlockchainHeaders, currentBlockHeaders: BlockchainHeaders) {\n  // $FlowFixMe - protbuf toObject is not typed\n  const headersToHashes = (headers: BlockchainHeaders) => Object.values(previousBlockHeaders.toObject()).reduce((acc, curr) => acc.concat(curr), []).map(headerObj => headerObj.hash)\n  const previousHashes = headersToHashes(previousBlockHeaders)\n  const currentHashes = headersToHashes(currentBlockHeaders)\n  const diff = difference(currentHashes, previousHashes)\n\n  const filterToDiff = currentBlockHeaders.filter((b) => {\n    if (diff.indexOf(b.getHash()) > -1) {\n      return b\n    }\n  })\n  return filterToDiff\n}\n\n/**\n * Used for preparing yet non existant BC block protobuf structure. Use before mining starts.\n *\n * - calculates block difficulty (from previous BC block difficulty and height, rovered chains count, and data in child chains headers) and stores it to structure\n * - stores headers of child chains (those being rovered)\n * - calculates new merkle root, hash and stores it to structure\n * - calculates new block height (previous + 1) and stores it to structure\n *\n * @param {number} currentTimestamp current timestamp reference\n * @param {BcBlock} lastPreviousBlock Last known previously mined BC block\n * @param {Block[]} newChildHeaders Child headers which were rovered since headers in lastPreviousBlock\n * @param {Block} blockWhichTriggeredMining The last rovered block - this one triggered the mining\n * @param {BcTransaction[]} newTransactions Transactions which will be added to newly mined block\n * @param {string} minerAddress Public addres to which NRG award for mining the block and transactions will be credited to\n * @param {BcBlock} unfinishedBlock If miner was running this is the block currently mined\n * @return {BcBlock} Prepared structure of the new BC block, does not contain `nonce` and `distance` which will be filled after successful mining of the block\n */\nexport function prepareNewBlock (currentTimestamp: number, lastPreviousBlock: BcBlock, newChildHeaders: Block[], blockWhichTriggeredMining: Block, newTransactions: BcTransaction[], minerAddress: string, unfinishedBlock: ?BcBlock): [BcBlock, number] {\n  let childBlockHeaders\n  if (lastPreviousBlock !== undefined && lastPreviousBlock.getHeight() === GENESIS_DATA.height) {\n    childBlockHeaders = prepareChildBlockHeadersMapForGenesis(newChildHeaders)\n  } else {\n    childBlockHeaders = prepareChildBlockHeadersMap(\n      unfinishedBlock || lastPreviousBlock,\n      blockWhichTriggeredMining,\n      newChildHeaders\n    )\n  }\n  const blockHashes = getChildrenBlocksHashes(blockchainMapToList(childBlockHeaders))\n  const newChainRoot = getChildrenRootHash(blockHashes)\n  const newBlockCount = getNewBlockCount(lastPreviousBlock.getBlockchainHeaders(), childBlockHeaders)\n  // const newBlockCount = getUniqueBlocks(lastPreviousBlock.getBlockchainHeaders(), childBlockHeaders).length\n\n  const preExpDiff = getNewPreExpDifficulty(\n    currentTimestamp,\n    lastPreviousBlock,\n    newBlockCount\n  )\n  const finalDifficulty = getExpFactorDiff(preExpDiff, lastPreviousBlock.getHeight()).toString()\n\n  const newHeight = lastPreviousBlock.getHeight() + 1\n  // blockchains, transactions, miner address, height\n  // TODO add EMB data to merkleRoot AT\n  const newMerkleRoot = createMerkleRoot(concatAll([\n    blockHashes,\n    newTransactions,\n    [\n      finalDifficulty,\n      minerAddress,\n      newHeight,\n      GENESIS_DATA.version,\n      GENESIS_DATA.schemaVersion,\n      GENESIS_DATA.nrgGrant,\n      GENESIS_DATA.blockchainFingerprintsRoot\n    ]\n  ]))\n\n  let chainWeight = 0\n  if (new BN(lastPreviousBlock.getHeight()).gt(2) === true) {\n    chainWeight = new BN(lastPreviousBlock.getDistance()).sub(new BN(lastPreviousBlock.getDifficulty())).divRound(new BN(4)).toString()\n  }\n\n  const newBlock = new BcBlock()\n  newBlock.setHash(blake2bl(lastPreviousBlock.getHash() + newMerkleRoot))\n  newBlock.setPreviousHash(lastPreviousBlock.getHash())\n  newBlock.setVersion(1)\n  newBlock.setSchemaVersion(1)\n  newBlock.setHeight(newHeight)\n  newBlock.setMiner(minerAddress)\n  newBlock.setDifficulty(finalDifficulty)\n  newBlock.setMerkleRoot(newMerkleRoot)\n  newBlock.setChainRoot(blake2bl(newChainRoot.toString()))\n  newBlock.setDistance(chainWeight) // is set to proper value after successful mining\n  newBlock.setTotalDistance(lastPreviousBlock.getTotalDistance()) // distance from mining solution will be added to this after mining\n  newBlock.setNrgGrant(GENESIS_DATA.nrgGrant)\n  newBlock.setTargetHash(GENESIS_DATA.targetHash)\n  newBlock.setTargetHeight(GENESIS_DATA.targetHeight)\n  newBlock.setTargetMiner(GENESIS_DATA.targetMiner)\n  newBlock.setTargetSignature(GENESIS_DATA.targetSignature)\n  newBlock.setTwn(GENESIS_DATA.twn) // Overline\n  newBlock.setTwsList(GENESIS_DATA.twsList) // Overline\n  newBlock.setEmblemWeight(GENESIS_DATA.emblemWeight)\n  newBlock.setEmblemChainBlockHash(GENESIS_DATA.emblemChainBlockHash)\n  newBlock.setEmblemChainFingerprintRoot(GENESIS_DATA.emblemChainFingerprintRoot)\n  newBlock.setEmblemChainAddress(GENESIS_DATA.emblemChainAddress)\n  newBlock.setTxCount(0)\n  newBlock.setTxsList(newTransactions)\n  newBlock.setBlockchainHeadersCount(newChildHeaders.length)\n  newBlock.setBlockchainFingerprintsRoot(GENESIS_DATA.blockchainFingerprintsRoot)\n  newBlock.setTxFeeBase(GENESIS_DATA.txFeeBase)\n  newBlock.setTxDistanceSumLimit(GENESIS_DATA.txDistanceSumLimit)\n  newBlock.setBlockchainHeaders(childBlockHeaders)\n\n  return [newBlock, currentTimestamp]\n}\n"]}